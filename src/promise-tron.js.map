{"version":3,"file":"promise-tron.js","sourceRoot":"","sources":["promise-tron.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  Event,\r\n  IpcMain,\r\n  IpcMainInvokeEvent,\r\n  IpcRenderer,\r\n  IpcRendererEvent,\r\n  WebContents\r\n} from 'electron'\r\n\r\n/**\r\n * PromiseTron is a promise based communication system which simplify data exchange between electron main\r\n * and renderer processes\r\n * @author Thomas Champagne\r\n * @licence MIT\r\n */\r\nexport class PromiseTron {\r\n  public static readonly REQUEST_FROM_RENDERER: string = 'promise-tron-request-from-renderer'\r\n  public static readonly REQUEST_FROM_MAIN: string = 'promise-tron-request-from-main'\r\n  public static readonly RESPONSE_TO_RENDERER: string = 'promise-tron-response-to-renderer'\r\n  public static readonly RESPONSE_TO_MAIN: string = 'promise-tron-response-to-main'\r\n\r\n  public readonly ipcMain: IpcMain\r\n  public readonly ipcRenderer: IpcRenderer\r\n  public readonly webContents: WebContents | null\r\n  public readonly isRenderer: boolean\r\n  public readonly isMain: boolean\r\n  public readonly logger: any\r\n\r\n  /**\r\n   * Instantiate PromiseTron\r\n   * @param ipc Pass IpcMain or IpcRenderer\r\n   * @param webContents Pass the webContents object of your BrowserWindow if you're on main thread\r\n   */\r\n  constructor(ipc: IpcMain | IpcRenderer, webContents?: WebContents) {\r\n    this.isRenderer = PromiseTron.isProcessRenderer()\r\n    this.isMain = !this.isRenderer\r\n    this.ipcMain = (this.isRenderer ? null : ipc) as IpcMain\r\n    this.ipcRenderer = (this.isRenderer ? ipc : null) as IpcRenderer\r\n    this.webContents = webContents ? webContents : null\r\n    if (this.isMain && webContents === null) {\r\n      throw new Error('You are in main mode: please pass WebContents in constructor')\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Tells if your are running into a renderer process. If false, you are in main process\r\n   */\r\n  public static isProcessRenderer(): boolean {\r\n    // node-integration is disabled\r\n    if (!process) {\r\n      return true\r\n    }\r\n\r\n    // We're in node.js somehow\r\n    if (!process.type) {\r\n      return false\r\n    }\r\n\r\n    return process.type === 'renderer'\r\n  }\r\n\r\n  /**\r\n   * Listen for {IpcRequest} from main thread if on a renderer thread\r\n   * Listen for {IpcRequest} from renderer thread if on a main thread\r\n   * @param onRequest Callback which provides incoming {IpcRequest} and replyWith function\r\n   */\r\n  public on(\r\n    onRequest: (\r\n      request: IpcRequest,\r\n      replyWith: (promiseTronReply: PromiseTronReply) => void\r\n    ) => void\r\n  ): void {\r\n    if (this.isMain) {\r\n      this.ipcMain.handle(\r\n        PromiseTron.REQUEST_FROM_RENDERER,\r\n        (event: IpcMainInvokeEvent, request: IpcRequest) => {\r\n          return new Promise(resolve => {\r\n            onRequest(request, (promiseTronReply: PromiseTronReply) => {\r\n              resolve(promiseTronReply)\r\n            })\r\n          })\r\n        }\r\n      )\r\n    } else if (this.isRenderer) {\r\n      this.ipcRenderer.on(\r\n        PromiseTron.REQUEST_FROM_MAIN,\r\n        (event: IpcRendererEvent, request: IpcRequest) => {\r\n          onRequest(request, (promiseTronReply: PromiseTronReply) => {\r\n            event.sender.send(request.responseId, promiseTronReply)\r\n          })\r\n        }\r\n      )\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send data to ipcMain if called from a renderer thread\r\n   * Send data to ipcRenderer if called from main thread\r\n   * @param data\r\n   * @return Promise of expected result\r\n   */\r\n  public send(data: any): Promise<any> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.isMain && this.webContents) {\r\n        const ipcRequest = new IpcRequest(data)\r\n\r\n        // Set the callback\r\n        this.ipcMain.once(\r\n          ipcRequest.responseId,\r\n          (event: Event, promiseTronReply: PromiseTronReply) => {\r\n            if (promiseTronReply.error) {\r\n              reject(promiseTronReply.error)\r\n            } else {\r\n              resolve(promiseTronReply.success)\r\n            }\r\n          }\r\n        )\r\n        // Send the request\r\n        this.webContents.send(PromiseTron.REQUEST_FROM_MAIN, ipcRequest)\r\n      } else if (this.isRenderer) {\r\n        this.ipcRenderer\r\n          .invoke(PromiseTron.REQUEST_FROM_RENDERER, new IpcRequest(data))\r\n          .then((promiseTronReply: PromiseTronReply) => {\r\n            if (promiseTronReply.error) {\r\n              reject(promiseTronReply.error)\r\n            } else {\r\n              resolve(promiseTronReply.success)\r\n            }\r\n          })\r\n          .catch(err => {\r\n            reject(err)\r\n          })\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport class PromiseTronReply {\r\n  public success: any\r\n  public error: any\r\n}\r\n\r\n/**\r\n * Object used to track communications between IpcMain & IpcRenderer\r\n */\r\nexport class IpcRequest {\r\n  private static GLOBAL_REQUEST_CREATED_COUNT: number = 0\r\n\r\n  /**\r\n   * Extract object from IpcRequest data\r\n   * @return T\r\n   */\r\n  public static extractData<T>(request: IpcRequest): T | null {\r\n    if (request.data) {\r\n      return request.data as T\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  /**\r\n   * Response identifier used by IpcMain to reply to IpcRenderer (or IpcRenderer to IpcMain)\r\n   */\r\n  public responseId: string\r\n\r\n  /**\r\n   * Request payload\r\n   */\r\n  public data: any\r\n\r\n  /**\r\n   *\r\n   * @param data Request payload\r\n   */\r\n  constructor(data: any) {\r\n    IpcRequest.GLOBAL_REQUEST_CREATED_COUNT++\r\n    this.responseId = IpcRequest.GLOBAL_REQUEST_CREATED_COUNT.toString()\r\n    this.data = data\r\n  }\r\n}\r\n"]}